"""
This type stub file was generated by pyright.
"""

from ..sendablebase import SendableBase
from typing import Any, Optional

"""
This type stub file was generated by pyright.
"""
__all__ = ["Command"]
class Command(SendableBase):
    """The Command class is at the very core of the entire command framework.
    Every command can be started with a call to start().
    Once a command is started it will call :meth:`initialize`, and then
    will repeatedly call :meth:`execute` until :meth:`isFinished` returns True.
    Once it does, :meth:`end` will be called.
    
    However, if at any point while it is running :meth:`cancel` is called, then
    the command will be stopped and :meth:`interrupted` will be called.
    
    If a command uses a :class:`.Subsystem`, then it should specify that it
    does so by calling the :meth:`requires` method in its constructor.
    Note that a Command may have multiple requirements, and :meth:`requires`
    should be called for each one.
    
    If a command is running and a new command with shared requirements is
    started, then one of two things will happen.  If the active command is
    interruptible, then :meth:`cancel` will be called and the command will be removed
    to make way for the new one.  If the active command is not interruptible,
    the other one will not even be started, and the active one will continue
    functioning.
    
    .. seealso:: :class:`.Subsystem`, :class:`.CommandGroup`
    """
    def __init__(self, name: Optional[Any] = ..., timeout: Optional[Any] = ..., subsystem: Optional[Any] = ...):
        """Creates a new command.
        
        :param name: The name for this command; if unspecified or None,
                     The name of this command will be set to its class name.
        :param timeout: The time (in seconds) before this command "times out".
                        Default is no timeout.  See isTimedOut().
        :param subsystem: The subsystem that this command requires
        """
        self.mutex = ...
        self.timeout = ...
        self.startTime = ...
        self.initialized = ...
        self.requirements = ...
        self.running = ...
        self.completed = ...
        self.interruptible = ...
        self.canceled = ...
        self.locked = ...
        self.runWhenDisabled = ...
        self.parent = ...
    
    def setTimeout(self, seconds):
        """Sets the timeout of this command.
        
        :param seconds: the timeout (in seconds)
        
        :see: :meth:`isTimedOut`
        """
        ...
    
    def timeSinceInitialized(self):
        """Returns the time since this command was initialized (in seconds).
        This function will work even if there is no specified timeout.
        
        :returns: the time since this command was initialized (in seconds).
        """
        ...
    
    def requires(self, subsystem):
        """This method specifies that the given Subsystem is used by this
        command.  This method is crucial to the functioning of the Command
        System in general.

        Note that the recommended way to call this method is in the
        constructor.

        :param subsystem: the :class:`.Subsystem` required
        """
        ...
    
    def removed(self):
        """Called when the command has been removed. This will call
        :meth:`interrupted` or :meth:`end`.
        """
        ...
    
    def run(self):
        """The run method is used internally to actually run the commands.
        
        :returns: whether or not the command should stay within the Scheduler.
        """
        ...
    
    def initialize(self):
        """The initialize method is called the first time this Command is run
        after being started.
        """
        ...
    
    def _initialize(self):
        """A shadow method called before initialize()."""
        ...
    
    def execute(self):
        """The execute method is called repeatedly until this Command either
        finishes or is canceled.
        """
        ...
    
    def _execute(self):
        """A shadow method called before execute()."""
        ...
    
    def isFinished(self):
        """Returns whether this command is finished.
        If it is, then the command will be removed and end() will be called.

        It may be useful for a team to reference the isTimedOut() method
        for time-sensitive commands, or override TimedCommand.

        If you do not specify isFinished in your command, the command will only
        end if interrupted or canceled. If you want a command that executes only
        once and then ends, override InstantCommand.

        :returns: whether this command is finished.
        :see: :meth:`isTimedOut`
        :see: :class: `.TimedCommand`
        :see: :class: `.InstantCommand`
        """
        ...
    
    def end(self):
        """Called when the command ended peacefully.  This is where you may
        want to wrap up loose ends, like shutting off a motor that was being
        used in the command.
        """
        ...
    
    def _end(self):
        """A shadow method called after end()."""
        ...
    
    def interrupted(self):
        """Called when the command ends because somebody called cancel() or
        another command shared the same requirements as this one, and booted
        it out.

        This is where you may want to wrap up loose ends, like shutting off a
        motor that was being used in the command.

        Generally, it is useful to simply call the end() method within this
        method, as done here.
        """
        ...
    
    def _interrupted(self):
        """A shadow method called after interrupted()."""
        ...
    
    def startTiming(self):
        """Called to indicate that the timer should start.
        This is called right before initialize() is, inside the run() method.
        """
        ...
    
    def isTimedOut(self):
        """Returns whether or not the :meth:`timeSinceInitialized` method returns a
        number which is greater than or equal to the timeout for the command.
        If there is no timeout, this will always return false.
        
        :returns: whether the time has expired
        """
        ...
    
    def getRequirements(self):
        """Returns the requirements (as a set of Subsystems) of this command
        """
        ...
    
    def lockChanges(self):
        """Prevents further changes from being made
        """
        ...
    
    def setParent(self, parent):
        """Sets the parent of this command.  No actual change is made to the
        group.

        :param parent: the parent
        """
        ...
    
    def isParented(self):
        """
        Returns whether the command has a parent.

        :returns: True if the command has a parent.
        """
        ...
    
    def clearRequirements(self):
        """Clears list of subsystem requirements. This is only used by
        :class:`.ConditionalCommand` so cancelling the chosen command works properly
        in :class:`.CommandGroup`.
        """
        ...
    
    def start(self):
        """Starts up the command.  Gets the command ready to start.
        Note that the command will eventually start, however it will not
        necessarily do so immediately, and may in fact be canceled before
        initialize is even called.
        """
        ...
    
    def startRunning(self):
        """This is used internally to mark that the command has been started.
        The lifecycle of a command is:

        * :meth:`startRunning` is called.
        * :meth:`run` is called (multiple times potentially)
        * :meth:`removed` is called

        It is very important that :meth:`startRunning` and :meth:`removed` be
        called in order or some assumptions of the code will be broken.
        """
        ...
    
    def isRunning(self):
        """Returns whether or not the command is running.
        This may return true even if the command has just been canceled, as it
        may not have yet called :meth:`interrupted`.
        
        :returns: whether or not the command is running
        """
        ...
    
    def cancel(self):
        """This will cancel the current command.

        This will cancel the current command eventually.  It can be called
        multiple times.  And it can be called when the command is not running.
        If the command is running though, then the command will be marked as
        canceled and eventually removed.

        .. warning:: A command can not be canceled if it is a part of a
                    :class:`.CommandGroup`, you must cancel the CommandGroup
                    instead.
        """
        ...
    
    def _cancel(self):
        """This works like cancel(), except that it doesn't throw an exception
        if it is a part of a command group.  Should only be called by the
        parent command group.
        """
        ...
    
    def isCanceled(self):
        """Returns whether or not this has been canceled.
        
        :returns: whether or not this has been canceled
        """
        ...
    
    def isCompleted(self) -> bool:
        """Whether or not this command has completed running.
        
        :returns: whether or not this command has completed running.
        """
        ...
    
    def isInterruptible(self):
        """Returns whether or not this command can be interrupted.
        
        :returns: whether or not this command can be interrupted
        """
        ...
    
    def setInterruptible(self, interruptible):
        """Sets whether or not this command can be interrupted.
        
        :param interruptible: whether or not this command can be interrupted
        """
        ...
    
    def doesRequire(self, system):
        """Checks if the command requires the given :class:`.Subsystem`.
        
        :param system: the system
        :returns: whether or not the subsystem is required, or False if given
                  None.
        """
        ...
    
    def getGroup(self):
        """Returns the :class:`.CommandGroup` that this command is a part of.
        Will return None if this Command is not in a group.
        
        :returns: the :class:`.CommandGroup` that this command is a part of
                  (or None if not in group)
        """
        ...
    
    def setRunWhenDisabled(self, run):
        """Sets whether or not this {@link Command} should run when the robot
        is disabled.

        By default a command will not run when the robot is disabled, and will
        in fact be canceled.

        :param run: whether or not this command should run when the robot is
                    disabled
        """
        ...
    
    def willRunWhenDisabled(self):
        """Returns whether or not this Command will run when the robot is
        disabled, or if it will cancel itself.
        """
        ...
    
    def __str__(self):
        """The string representation for a Command is by default its name.
        
        :returns: the string representation of this object
        """
        ...
    
    def runningChanged(self, value):
        ...
    
    def initSendable(self, builder):
        ...
    


