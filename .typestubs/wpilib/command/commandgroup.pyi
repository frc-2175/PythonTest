"""
This type stub file was generated by pyright.
"""

from .command import Command
from typing import Any, Optional

"""
This type stub file was generated by pyright.
"""
__all__ = ["CommandGroup"]
class CommandGroup(Command):
    """A CommandGroup is a list of commands which are executed in sequence.

    Commands in a CommandGroup are added using the :meth:`addSequential` method
    and are called sequentially. CommandGroups are themselves Commands and can
    be given to other CommandGroups.

    CommandGroups will carry all of the requirements of their subcommands.
    Additional requirements can be specified by calling :meth:`requires`
    normally in the constructor.

    CommandGroups can also execute commands in parallel, simply by adding them
    using addParallel(...).

    .. seealso:: :class:`.Command`, :class:`Subsystem`
    """
    class Entry:
        IN_SEQUENCE = ...
        BRANCH_PEER = ...
        BRANCH_CHILD = ...
        def __init__(self, command, state, timeout):
            self.command = ...
            self.state = ...
            self.timeout = ...
        
        def isTimedOut(self):
            ...
        
    
    
    def __init__(self, name: Optional[Any] = ...):
        """Creates a new CommandGroup with the given name.
        
        :param name: the name for this command group (optional).  If None,
                     the name of this command will be set to its class name.
        """
        self.commands = ...
        self.children = ...
        self.currentCommandIndex = ...
    
    def addSequential(self, command, timeout: Optional[Any] = ...):
        """Adds a new Command to the group (with an optional timeout).
        The Command will be started after all the previously added Commands.

        Once the Command is started, it will be run until it finishes or the
        time expires, whichever is sooner (if a timeout is provided).  Note
        that the given Command will have no knowledge that it is on a timer.

        Note that any requirements the given Command has will be added to the
        group.  For this reason, a Command's requirements can not be changed
        after being added to a group.

        It is recommended that this method be called in the constructor.

        :param command: The Command to be added
        :param timeout: The timeout (in seconds) (optional)
        """
        ...
    
    def addParallel(self, command, timeout: Optional[Any] = ...):
        """Adds a new child Command to the group (with an optional timeout).
        The Command will be started after all the previously added Commands.

        Once the Command is started, it will run until it finishes, is
        interrupted, or the time expires (if a timeout is provided), whichever
        is sooner.  Note that the given Command will have no knowledge that it
        is on a timer.

        Instead of waiting for the child to finish, a CommandGroup will have it
        run at the same time as the subsequent Commands.  The child will run
        until either it finishes, the timeout expires, a new child with
        conflicting requirements is started, or the main sequence runs a
        Command with conflicting requirements.  In the latter two cases, the
        child will be canceled even if it says it can't be interrupted.

        Note that any requirements the given Command has will be added to the
        group.  For this reason, a Command's requirements can not be changed
        after being added to a group.

        It is recommended that this method be called in the constructor.

        :param command: The command to be added
        :param timeout: The timeout (in seconds) (optional)
        """
        ...
    
    def _initialize(self):
        self.currentCommandIndex = ...
    
    def _execute(self):
        ...
    
    def _end(self):
        ...
    
    def _interrupted(self):
        ...
    
    def isFinished(self):
        """Returns True if all the Commands in this group
        have been started and have finished.

        Teams may override this method, although they should probably
        reference super().isFinished() if they do.

        :returns: whether this CommandGroup is finished
        """
        ...
    
    def initialize(self):
        ...
    
    def execute(self):
        ...
    
    def end(self):
        ...
    
    def interrupted(self):
        ...
    
    def isInterruptible(self):
        """Returns whether or not this group is interruptible.
        A command group will be uninterruptible if setInterruptable(False)
        was called or if it is currently running an uninterruptible command
        or child.

        :returns: whether or not this CommandGroup is interruptible.
        """
        ...
    
    def cancelConflicts(self, command):
        ...
    


