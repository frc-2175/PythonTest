"""
This type stub file was generated by pyright.
"""

import enum
from typing import Any, List, Optional, Union

"""
This type stub file was generated by pyright.
"""
__all__ = ["I2C"]
def _freeI2C(port: I2C.Port) -> None:
    ...

class I2C:
    """I2C bus interface class.

    This class is intended to be used by sensor (and other I2C device) drivers.
    It probably should not be used directly.
    
    Example usage::
    
        i2c = wpilib.I2C(wpilib.I2C.Port.kOnboard, 4)
        
        # Write bytes 'text', and receive 4 bytes in data
        data = i2c.transaction(b'text', 4)
    """
    class Port(enum.IntEnum):
        kOnboard = ...
        kMXP = ...
    
    
    def __init__(self, port: Port, deviceAddress: int, simPort: Optional[Any] = ...) -> None:
        """Constructor.

        :param port: The I2C port the device is connected to.
        :param deviceAddress: The address of the device on the I2C bus.
        :param simPort: This must be an object that implements all of
                        the i2c* functions from hal_impl that you use.
                        See ``test_i2c.py`` for an example.
        """
        self.deviceAddress = ...
    
    def free(self) -> None:
        """
        .. deprecated:: 2019.0.0
            Use close instead
        """
        ...
    
    def close(self) -> None:
        self.port = ...
    
    def transaction(self, dataToSend: Union[bytes, List[int]], receiveSize: int) -> bytes:
        """Generic transaction.

        This is a lower-level interface to the I2C hardware giving you more
        control over each transaction. If you intend to write multiple bytes
        in the same transaction and do not plan to receive anything back, use
        writeBulk() instead. Calling this with a receiveSize of 0 will
        result in an error.

        :param dataToSend: Buffer of data to send as part of the transaction.
        :param receiveSize: Number of bytes to read from the device.
        :returns: Data received from the device.
        """
        ...
    
    def addressOnly(self) -> bool:
        """Attempt to address a device on the I2C bus.

        This allows you to figure out if there is a device on the I2C bus that
        responds to the address specified in the constructor.

        :returns: Transfer Aborted... False for success, True for aborted.
        """
        ...
    
    def write(self, registerAddress: int, data: int) -> bool:
        """Execute a write transaction with the device.

        Write a single byte to a register on a device and wait until the
        transaction is complete.

        :param registerAddress:
            The address of the register on the device to be written.
        :param data: The byte to write to the register on the device.
        :returns: Transfer Aborted... False for success, True for aborted.
        """
        ...
    
    def writeBulk(self, data: bytes) -> bool:
        """Execute a write transaction with the device.

        Write multiple bytes to a register on a device and wait until the
        transaction is complete.

        :param data: The data to write to the device.
        :returns: Transfer Aborted... False for success, True for aborted.
        
        Usage::
        
            # send byte string
            failed = i2c.writeBulk(b'stuff')
            
            # send list of integers
            failed = i2c.write([0x01, 0x02])
        """
        ...
    
    def read(self, registerAddress: int, count: int) -> bytearray:
        """Execute a read transaction with the device.

        Read bytes from a device. Most I2C devices will auto-increment
        the register pointer internally allowing you to read
        consecutive registers on a device in a single transaction.

        :param registerAddress: The register to read first in the transaction.
        :param count: The number of bytes to read in the transaction.
        :returns: The data read from the device.
        """
        ...
    
    def readOnly(self, count: int) -> bytes:
        """Execute a read only transaction with the device.

        Read bytes from a device. This method does not write any data
        to prompt the device.

        :param count: The number of bytes to read in the transaction.
        :returns: The data read from the device.
        """
        ...
    
    def verifySensor(self, registerAddress: int, expected: bytes) -> bool:
        """Verify that a device's registers contain expected values.

        Most devices will have a set of registers that contain a known value
        that can be used to identify them. This allows an I2C device driver
        to easily verify that the device contains the expected value.

        The device must support and be configured to use register
        auto-increment.

        :param registerAddress:
            The base register to start reading from the device.
        :param expected: The values expected from the device.
        :returns: True if the sensor was verified to be connected
        """
        ...
    


