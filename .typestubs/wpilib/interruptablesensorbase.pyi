"""
This type stub file was generated by pyright.
"""

import enum
from typing import Callable, Optional
from .sendablebase import SendableBase

"""
This type stub file was generated by pyright.
"""
__all__ = ["InterruptableSensorBase"]
class InterruptableSensorBase(SendableBase):
    """Base for sensors to be used with interrupts"""
    class WaitResult(enum.IntEnum):
        kTimeout = ...
        kRisingEdge = ...
        kFallingEdge = ...
        kBoth = ...
    
    
    def __init__(self) -> None:
        """Create a new InterrupatableSensorBase"""
        self.interrupt = ...
        self.isSynchronousInterrupt = ...
    
    def close(self) -> None:
        ...
    
    def getAnalogTriggerTypeForRouting(self) -> int:
        ...
    
    def getPortHandleForRouting(self) -> int:
        ...
    
    def requestInterrupts(self, handler: Optional[Callable[[int], None]] = ...) -> None:
        """Request one of the 8 interrupts asynchronously on this digital
        input.

        :param handler: (optional)
            The function that will be called whenever there is an interrupt
            on this device.  Request interrupts in synchronous mode where the
            user program interrupt handler will be called when an interrupt
            occurs. The default is interrupt on rising edges only.  If not
            specified, the user program will have to explicitly wait for the
            interrupt to occur using waitForInterrupt.
        """
        ...
    
    def allocateInterrupts(self, watcher: bool) -> None:
        """Allocate the interrupt

        :param watcher: True if the interrupt should be in synchronous mode
            where the user program will have to explicitly wait for the interrupt
            to occur.
        """
        self.isSynchronousInterrupt = ...
        self.interrupt = ...
    
    def cancelInterrupts(self) -> None:
        """Cancel interrupts on this device. This deallocates all the
        chipobject structures and disables any interrupts.
        """
        self.interrupt = ...
    
    def waitForInterrupt(self, timeout: float, ignorePrevious: bool = ...) -> int:
        """In synchronous mode, wait for the defined interrupt to occur.
        You should **NOT** attempt to read the sensor from another thread
        while waiting for an interrupt. This is not threadsafe, and can cause 
        memory corruption

        :param timeout: Timeout in seconds
        :param ignorePrevious: If True (default), ignore interrupts that
            happened before waitForInterrupt was called.
        """
        ...
    
    def enableInterrupts(self) -> None:
        """Enable interrupts to occur on this input. Interrupts are disabled
        when the RequestInterrupt call is made. This gives time to do the
        setup of the other options before starting to field interrupts.
        """
        ...
    
    def disableInterrupts(self) -> None:
        """Disable Interrupts without without deallocating structures."""
        ...
    
    def readRisingTimestamp(self) -> float:
        """Return the timestamp for the rising interrupt that occurred most
        recently.  This is in the same time domain as getClock().  The
        rising-edge interrupt should be enabled with setUpSourceEdge.

        :returns: Timestamp in seconds since boot.
        """
        ...
    
    def readFallingTimestamp(self) -> float:
        """Return the timestamp for the falling interrupt that occurred most
        recently.  This is in the same time domain as getClock().  The
        falling-edge interrupt should be enabled with setUpSourceEdge.

        :returns: Timestamp in seconds since boot.
        """
        ...
    
    def setUpSourceEdge(self, risingEdge: bool, fallingEdge: bool) -> None:
        """Set which edge to trigger interrupts on

        :param risingEdge: True to interrupt on rising edge
        :param fallingEdge: True to interrupt on falling edge
        """
        ...
    


