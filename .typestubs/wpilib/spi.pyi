"""
This type stub file was generated by pyright.
"""

import enum
from typing import Any, Optional, Sequence, Tuple, Union
from .accumulatorresult import AccumulatorResult
from .digitalsource import DigitalSource

"""
This type stub file was generated by pyright.
"""
__all__ = ["SPI"]
def _freeSPI(port) -> None:
    ...

class SPI:
    """Represents a SPI bus port

    Example usage::

        spi = wpilib.SPI(wpilib.SPI.Port.kOnboardCS0)

        # Write bytes 'text', and receive something
        data = spi.transaction(b'text')

    """
    class Port(enum.IntEnum):
        kOnboardCS0 = ...
        kOnboardCS1 = ...
        kOnboardCS2 = ...
        kOnboardCS3 = ...
        kMXP = ...
    
    
    devices = ...
    @staticmethod
    def _reset() -> None:
        ...
    
    def __init__(self, port: Port, simPort: Optional[Any] = ...) -> None:
        """Constructor

        :param port: the physical SPI port
        :param simPort: This must be an object that implements all of
                        the spi* functions from hal_impl that you use.
                        See ``test_spi.py`` for an example.
        """
        self.msbFirst = ...
        self.clockIdleHigh = ...
        self.sampleOnTrailing = ...
        self.accum = ...
    
    def close(self) -> None:
        self.port = ...
    
    def setClockRate(self, hz: int) -> None:
        """Configure the rate of the generated clock signal. The default value is 500,000 Hz. The maximum
        value is 4,000,000 Hz.

        :param hz: The clock rate in Hertz.
        """
        ...
    
    def setMSBFirst(self) -> None:
        """Configure the order that bits are sent and received on the wire to be most significant bit
        first.
        """
        self.msbFirst = ...
    
    def setLSBFirst(self) -> None:
        """Configure the order that bits are sent and received on the wire to be least significant bit
        first.
        """
        self.msbFirst = ...
    
    def setClockActiveLow(self) -> None:
        """Configure the clock output line to be active low. This is sometimes called clock polarity high
        or clock idle high.
        """
        self.clockIdleHigh = ...
    
    def setClockActiveHigh(self) -> None:
        """Configure the clock output line to be active high. This is sometimes called clock polarity low
        or clock idle low.
        """
        self.clockIdleHigh = ...
    
    def setSampleDataOnLeadingEdge(self) -> None:
        """Configure that the data is stable on the leading edge and the data changes on the trailing edge."""
        self.sampleOnTrailing = ...
    
    def setSampleDataOnTrailingEdge(self) -> None:
        """Configure that the data is stable on the trailing edge and the data changes on the leading edge."""
        self.sampleOnTrailing = ...
    
    def setSampleDataOnFalling(self) -> None:
        """
        Configure that the data is stable on the falling edge and the data changes on the rising edge.
        Note that this gets reversed if setClockActiveLow is set

        .. deprecated:: 2019.0.0
            Use setSampleDataOnTrailingEdge in most cases
        """
        self.sampleOnTrailing = ...
    
    def setSampleDataOnRising(self) -> None:
        """
        Configure that the data is stable on the rising edge and the data changes on the falling edge.

        .. deprecated:: 2019.0.0
            Use setSampleDataOnLeadingEdge in most cases
        """
        self.sampleOnTrailing = ...
    
    def setChipSelectActiveHigh(self) -> None:
        """Configure the chip select line to be active high."""
        ...
    
    def setChipSelectActiveLow(self) -> None:
        """Configure the chip select line to be active low."""
        ...
    
    def write(self, dataToSend: Union[bytes, Sequence[int]]) -> int:
        """Write data to the slave device.  Blocks until there is space in the
        output FIFO.

        If not running in output only mode, also saves the data received
        on the MISO input during the transfer into the receive FIFO.

        :param dataToSend: Data to send

        :returns: Number of bytes written

        Usage::

            # send byte string
            writeCount = spi.write(b'stuff')

            # send list of integers
            writeCount = spi.write([0x01, 0x02])
        """
        ...
    
    def read(self, initiate: bool, size: int) -> bytes:
        """Read a word from the receive FIFO.

        Waits for the current transfer to complete if the receive FIFO is
        empty.

        If the receive FIFO is empty, there is no active transfer, and
        initiate is False, errors.

        :param initiate: If True, this function pushes "0" into the
            transmit buffer and initiates a transfer.  If False, this function
            assumes that data is already in the receive FIFO from a previous
            write.
        :param size: Number of bytes to read.

        :returns: received data bytes
        """
        ...
    
    def transaction(self, dataToSend: Union[bytes, Sequence[int]]) -> bytes:
        """Perform a simultaneous read/write transaction with the device

        :param dataToSend: The data to be written out to the device

        :returns: data received from the device

        Usage::

            # send byte string
            data = spi.transaction(b'stuff')

            # send list of integers
            data = spi.transaction([0x01, 0x02])
        """
        ...
    
    def initAuto(self, bufferSize: int) -> None:
        """Initialize automatic SPI transfer engine.

        Only a single engine is available, and use of it blocks use of all other
        chip select usage on the same physical SPI port while it is running.

        :param bufferSize: buffer size in bytes
        """
        ...
    
    def freeAuto(self) -> None:
        """Frees the automatic SPI transfer engine."""
        ...
    
    def setAutoTransmitData(self, dataToSend: bytes, zeroSize: int) -> None:
        """Set the data to be transmitted by the engine.

        Up to 16 bytes are configurable, and may be followed by up to 127 zero
        bytes.

        :param dataToSend: data to send (maximum 16 bytes)
        :param zeroSize: number of zeros to send after the data
        """
        ...
    
    def startAutoRate(self, period: float) -> None:
        """Start running the automatic SPI transfer engine at a periodic rate.

        :meth:`.initAuto` and :meth:`.setAutoTransmitData` must
        be called before calling this function.

        :param period: period between transfers, in seconds (us resolution)
        """
        ...
    
    def startAutoTrigger(self, source: DigitalSource, rising: bool, falling: bool) -> None:
        """Start running the automatic SPI transfer engine when a trigger occurs.

        :meth:`.initAuto` and :meth:`.setAutoTransmitData` must
        be called before calling this function.

        :param source: digital source for the trigger (may be an analog trigger)
        :param rising: trigger on the rising edge
        :param falling: trigger on the falling edge
        """
        ...
    
    def stopAuto(self) -> None:
        """Stop running the automatic SPI transfer engine."""
        ...
    
    def forceAutoRead(self) -> None:
        """Force the engine to make a single transfer."""
        ...
    
    def readAutoReceivedData(self, buffer: bytes, numToRead: int, timeout: float) -> Tuple[int, bytes]:
        """Read data that has been transferred by the automatic SPI transfer engine.

        Transfers may be made a byte at a time, so it's necessary for the caller
        to handle cases where an entire transfer has not been completed.

        Each received data sequence consists of a timestamp followed by the
        received data bytes, one byte per word (in the least significant byte).
        The length of each received data sequence is the same as the combined
        size of the data and zeroSize set in setAutoTransmitData().

        Blocks until numToRead words have been read or timeout expires.
        May be called with numToRead=0 to retrieve how many words are available.

        :param buffer:    A ctypes c_uint32 buffer to read the data into
        :param numToRead: number of words to read
        :param timeout:   timeout in seconds (ms resolution)
        
        :returns: Number of words remaining to be read
        """
        ...
    
    def getAutoDroppedCount(self) -> int:
        """Get the number of bytes dropped by the automatic SPI transfer engine due
        to the receive buffer being full.

        :returns: Number of bytes dropped
        """
        ...
    
    class _Accumulator:
        kAccumulateDepth = ...
        def __init__(self, port: int, xferSize: int, validMask: int, validValue: int, dataShift: int, dataSize: int, isSigned: bool, bigEndian: bool) -> None:
            ...
        
        def free(self) -> None:
            """
            .. deprecated:: 2019.0.0
                Use close instead
            """
            ...
        
        def close(self):
            ...
        
        def _update(self) -> None:
            ...
        
    
    
    def initAccumulator(self, period: float, cmd: int, xferSize: int, validMask: int, validValue: int, dataShift: int, dataSize: int, isSigned: bool, bigEndian: bool) -> None:
        """Initialize the accumulator.

        :param period: Time between reads
        :param cmd: SPI command to send to request data
        :param xferSize: SPI transfer size, in bytes
        :param validMask: Mask to apply to received data for validity checking
        :param validValue: After validMask is applied, required matching value for validity checking
        :param dataShift: Bit shift to apply to received data to get actual data value
        :param dataSize: Size (in bits) of data field
        :param isSigned: Is data field signed?
        :param bigEndian: Is device big endian?
        """
        self.accum = ...
    
    def freeAccumulator(self) -> None:
        """Frees the accumulator."""
        ...
    
    def resetAccumulator(self) -> None:
        """Resets the accumulator to zero."""
        ...
    
    def setAccumulatorCenter(self, center: int) -> None:
        """Set the center value of the accumulator.

        The center value is subtracted from each value before it is added to the accumulator. This
        is used for the center value of devices like gyros and accelerometers to make integration work
        and to take the device offset into account when integrating.
        """
        ...
    
    def setAccumulatorDeadband(self, deadband: int) -> None:
        """Set the accumulator's deadband."""
        ...
    
    def getAccumulatorLastValue(self) -> int:
        """Read the last value read by the accumulator engine."""
        ...
    
    def getAccumulatorValue(self) -> int:
        """Read the accumulated value.

        :returns: The 64-bit value accumulated since the last Reset().
        """
        ...
    
    def getAccumulatorCount(self) -> int:
        """Read the number of accumulated values.

        Read the count of the accumulated values since the accumulator was last Reset().

        :returns: The number of times samples from the channel were accumulated.
        """
        ...
    
    def getAccumulatorAverage(self) -> float:
        """Read the average of the accumulated value.

        :returns: The accumulated average value (value / count).
        """
        ...
    
    def getAccumulatorOutput(self) -> AccumulatorResult:
        """Read the accumulated value and the number of accumulated values atomically.

        This function reads the value and count atomically.
        This can be used for averaging.

        :returns: tuple of (value, count)
        """
        ...
    
    def setAccumulatorIntegratedCenter(self, center: float) -> None:
        """Set the center value of the accumulator integrator.

        The center value is subtracted from each value*dt before it is added to the
        integrated value. This is used for the center value of devices like gyros
        and accelerometers to take the device offset into account when integrating.

        """
        ...
    
    def getAccumulatorIntegratedValue(self) -> float:
        """Read the integrated value.  This is the sum of (each value * time between
        values).

        :returns: The integrated value accumulated since the last Reset().
        """
        ...
    
    def getAccumulatorIntegratedAverage(self) -> float:
        """Read the average of the integrated value.  This is the sum of (each value
        times the time between values), divided by the count.

        :returns: The average of the integrated value accumulated since the last Reset().
        """
        ...
    


